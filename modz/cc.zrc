

export CC_COMPILER
export CC_LINKER
export CC_CFLAGS
export CC_LDFLAGS
export MAKE=gmake

if ((OS_MAC)) ; then
    CC=clang
    CXX=clang++
    MACOS_SDK_PATH="`xcrun --show-sdk-path`"
    export MACOSX_DEPLOYMENT_TARGET=10.12
    # [ -d /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ ] && {
    #     /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/
    # }
    # -flat_namespace
    # see tcc,,,

    # sudo rm -rf /Library/Developer/CommandLineTools
    # xcode-select --install
else
    CC=gcc
    CXX=g++
fi

alias CC_ENV='CC_EXPORT && \
    CC="$CC" CXX="$CXX" MAKE="$MAKE" \
    CFLAGS="$CC_CFLAGS" LDFLAGS="$CC_LDFLAGS"'

CC ()
{
    CC_EXPORT;
    log: $CC_COMPILER ${=CC_CFLAGS} ${=CC_LDFLAGS} -I"$PREFIX"/include -I"$PKGWD" $CFLAGS $argv
}
LINK ()
{
    CC_EXPORT;
    log: $LINKER ${=CC_CFLAGS} ${=CC_LDFLAGS} $argv
}

CC_EXPORT ()
{
    CC_CFLAGS=" -fno-math-errno -fno-signed-zeros"
        # -fno-strict-aliasing
    CC_LDFLAGS=""

    if ((BLD_WEBGL)); then
        CC_COMPILER="emcc"
        CC_LINKER="emcc"
    else
        CC_COMPILER=$CC
        CC_LINKER=$CC
    fi

    if ((BLD_DEV)); then
        CC_CFLAGS+=" -O0 -Wall -g"
    else
        # https://gcc.gnu.org/onlinedocs/gcc-4.9.1/gcc/Optimize-Options.html
        if ((BLD_WEBGL)); then
            CC_CFLAGS+=" -O3 -mnontrapping-fptoint -fno-exceptions"
                # https://emscripten.org/docs/compiling/WebAssembly.html#trapping
                # The LLVM wasm backend avoids traps by adding more code around each possible trap (basically clamping the value if it would trap). This can increase code size and decrease speed, if you don’t need that extra code. The proper solution for this is to use newer wasm instructions that do not trap, by calling emcc or clang with -mnontrapping-fptoint. That code may not run in older VMs, though.
            CC_CFLAGS+=" --closure 1"
                # https://emscripten.org/docs/optimizing/Optimizing-Code.html#link-times
        else
            CC_CFLAGS+=" -Ofast"
        fi
    fi


    if ((BLD_WEBGL)); then
        CC_CFLAGS+=" -std=gnu2x --memory-init-file 1 -s MIN_WEBGL_VERSION=2 -s USE_WEBGL2=1 -s MAX_WEBGL_VERSION=2"
        # -s FULL_ES3=1  # https://emscripten.org/docs/optimizing/Optimizing-WebGL.html#which-gl-mode-to-target
        CC_CFLAGS+=" -s ALLOW_MEMORY_GROWTH=1"
        CC_CFLAGS+=" -fno-pic -fno-pie -fno-strict-aliasing"
        # --use-preload-plugins

        # linker flags
        CC_LDFLAGS+=" -s EXPORTED_FUNCTIONS=['_main']"
        # OFLAGS+=(--preload-file "./data")
        # OFLAGS+="--emrun"
    else
        CC_CFLAGS+=" -std=gnu2x -march=native -mtune=native -fpic -fno-strict-aliasing"
        CC_CFLAGS+=" -Wno-unused-function -Wno-incompatible-pointer-types"

        ((OS_MAC)) &&
            CC_CFLAGS+=" -flto=thin" # https://clang.llvm.org/docs/ThinLTO.html
    fi
}



# https://stackoverflow.com/questions/61986265/why-gcc-mcmodel-large-adds-an-offset-to-the-function-call-even-with-no-pie-fla
# -fpic vs -fPIC
    # When generating code for shared libraries, -fpic implies -msmall-data and -fPIC implies -mlarge-data.
    # -msmall-data -mlarge-data http://man7.org/linux/man-pages/man1/gcc.1.html
    #    When -mexplicit-relocs is in effect, static data is accessed via
    #    gp-relative relocations.  When -msmall-data is used, objects 8
    #    bytes long or smaller are placed in a small data area (the
    #    ".sdata" and ".sbss" sections) and are accessed via 16-bit
    #    relocations off of the $gp register.  This limits the size of the
    #    small data area to 64KB, but allows the variables to be directly
    #    accessed via a single instruction.

    #    The default is -mlarge-data.  With this option the data area is
    #    limited to just below 2GB.  Programs that require more than 2GB
    #    of data must use "malloc" or "mmap" to allocate the data in the
    #    heap instead of in the program's data segment.

    #    When generating code for shared libraries, -fpic implies
    #    -msmall-data and -fPIC implies -mlarge-data.

    # Compiling position-independent code when not necessary is a performance drag on some platforms (most notably, the register-starved x86 architecture, because PIC takes away a register that can be used more freely when non-PIC), but there should be no detrimental effects otherwise.

# -no-pie
#   is only a linker option
#   Don’t produce a dynamically linked position independent executable.
# -fno-pic or -fno-pie are code-gen options.
# -fpic
    # Position Independent Code means that the generated machine code is not dependent on being located at a specific address in order to work.
    # E.g. jumps would be generated as relative rather than absolute.
    # code compiled with -fPIC, it's suitable for inclusion in a library
    # Code that is built into shared libraries should normally be position-independent code, so that the shared library can readily be loaded at (more or less) any address in memory
# OFLAGS+="-no-pie"

# -O3
# -pipe
